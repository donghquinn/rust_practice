# [소유권](https://rinthel.github.io/rust-lang-book-ko/ch04-01-what-is-ownership.html)
- RUST의 핵심 기능
- 기존의 프로그래밍 언어들은 메모리 관리에 애를 먹는다.
    - 더 이상 사용하지 않는 메모리를 찾는 가비지 콜렉션을 가지고 있다.
    - 메모리를 할당하고 해제시켜야 한다.
- 러스트는 소유권 시스템을 통해 메모리를 관리한다.

## 소유권 규칙
- 러스트에서 각각의 값은 해당 값의 오너(owner)라 불리는 변수를 가지고 있다.
- 한번에 딱 하나의 오너만 존재 가능.
- 오너가 스코프 밖으로 벗어날 때, 값은 버려진다.


## 더블 콜론(::)
- 어떤 타입의 아래에 어떤 함수를 지정할 때 사용하는 네임 스페이스 연산자.
- 쉽게 말하자면 어떤 클래스(라이브러리, 패키지 등 mod)의 메서드를 호출하는 연산자처럼 이해하는게 빠르다.
```
    let s = String::from("Hello");
```

## 메모리와 할당
- 기본적으로는 컴파일 중에 문자열의 크기를 알기 때문에, 최종 실행파일에 해당 문자열에 하드 코딩 되었다.
    - 그러나 이는 문자열이 변하지 않는다는 전제가 있을 때만 가능하다.
- 그러나 그 내용물과 크기를 알 수 없는 텍스트를 최종 실행 파일(바이너리 파일)에 넣을 수 없다.
- 따라서 컴파일 시에 알 수 없는 텍스트에 대해 어느 정도의 메모리를 할당받아 사용한다.
    1. 런타임에 운영체제로부터 메모리가 요청되어야 한다.
    2. 해당 내용물을 알 수 없었던 타입의 사용이 종료되었을 때, 메모리를 운영체제에 반납할 수 있어야 한다.
- 1번 메모리 요청은 String::from("Hello); 로 구현 가능하다.
- 2번은 다른 언어에서는 가비지 콜렉터가 수행한다.
    - 가비지 콜렉터가 없는 언어의 경우, 프로그래머가 직접 메모리를 할당하고 해제한다.
- RUST는 변수가 스코프 밖으로 벗어나는 순간( } 로 닫힐 때) 메모리를 반납한다.
    - 이렇게 스코프 밖으로 벗어날 때, 메모리 반납하는 함수를 drop함수라고 한다.
    - RUST는 스코프를 벗어날 때 drop 함수를 자동으로 불러온다.


```
    {                      // s는 유효하지 않습니다. 아직 선언이 안됐거든요.
        let s = "hello";   // s는 이 지점부터 유효합니다.

        // s를 가지고 뭔가 합니다.
    }                      // 이 스코프는 이제 끝이므로, s는 더이상 유효하지 않습니다.
```

## 변수 간 상호작용법: 이동
- 문자열 변수를 선언하였을 때, 포인터, 길이, 용량(capacity) 이렇게 저장이 된다.
    - 이렇게 생성된 데이터 그룹은 스택에 저장된다.
    - 포인터가 가리키는 문자열 내용은 힙 메모리에 저장된다.
- 만일 변수 y가 x의 값을 할당한다면, x를 복사하여 y에 할당하게 될 것이다.
    - 복사한다는 것은, 메모리 포인터 + 길이 + 용량을 복사한다는 의미이다.
    - 따라서 두 데이터 그룹 x, y는 같은 힙 메모리를 포인터로 가지고 있다.
    - 만약 힙 메모리의 데이터까지 복사한다는 것 이었다면 메모리 용량 차지와 연산 속도의 하락을 야기할 것이다.

```
    let x = String::from("hello");
    let y = x;          // x 데이터 그룹 내용을 복사하여 할당.
```

- 그런데 두 변수가 같은 힙 데이터를 포인터로 가지고 있을 때, 먼저 선언된 변수가 스코프를 벗어나 메모리가 해제된다면?
    - 메모리를 두번 해제하는 보안 문제가 발생할 수 있다.
    - 따라서 러스트는 이러한 경우 '이동 에러(Move Error)'를 발생시킨다.
- 포인터, 길이, 용량을 복사한다는 점에서 다른 언어의 '얕은 복사'와 유사하다.
    - 하지만 첫번째 변수를 무효화 하기 때문에 RUST는 "이동(MOVE)"라고 한다.
- 따라서 첫번째 변수만이 혼자 메모리를 해제하게 된다.

## 변수 간 상호작용법: 클론
- 힙 메모리의 데이터까지 복사하는 방법
- 공용 메소드 clone()을 사용하면 된다.
- 다만 비용이 많이 발생하는 방식이다.
```
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);

```

## 스택에만 있는 데이터: 복사
- 아래 예시는 위의 메모리 할당과 해제와 대척된다고 생각될 수 있다.
    - clone 호출 없이 x도 유효하고 y로 이동하지도 않았기 때문.
```
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```
- 왜냐하면 문자열과 달리 "정수형 / 불린형 / 부동 소수점형 / 이들로 구성된 튜플" 은 이미 그 크기가 컴파일 단계에서 알려져 있기 때문.
    - 따라서 컴파일 단계에서 모두 스택에 저장되어 있음
    - 다시 말해 y가 생성된 후에 x가 더 이상 유효하지 않게 할 이유가 없다는 의미 == 얕은 복사 / 깊은 복사간 차이가 없음